<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Falcon — Top-View Landing (Final)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body { height:100%; margin:0; background:#000; color:#ddd;
font-family:Inter,Arial,sans-serif; overflow:hidden; }
    #ui { position:absolute; left:12px; top:12px; z-index:60;
width:360px; background:rgba(0,0,0,0.56); padding:12px;
border-radius:10px; backdrop-filter:blur(4px); }
    #ui h1{margin:0 0 6px 0;font-size:16px}
    #hud{font-family:monospace; white-space:pre; margin-top:6px; font-size:13px}
    #score{font-weight:700;margin-top:8px}
    #loading{color:#ffd480;margin-top:6px}
    #controls{margin-top:8px;font-size:13px;color:#bfe6ff}
    #quality{width:100%; margin-top:8px}
    #resetBtn{margin-top:8px;padding:8px
10px;background:#1f6feb;color:white;border:none;border-radius:6px;cursor:pointer;font-weight:600}
    #centerBtn{margin-left:8px;padding:8px
10px;background:#3b3b3b;color:white;border:none;border-radius:6px;cursor:pointer}
    #leaderboard { position:absolute; right:12px; top:12px;
z-index:60; width:220px; background: rgba(0,0,0,0.5); padding:10px;
border-radius:8px; }
    #leaderboard h3{margin:0 0 6px 0;font-size:14px}
    #nameModal { position:fixed; left:0; top:0; right:0; bottom:0;
display:flex; align-items:center; justify-content:center;
background:rgba(0,0,0,0.6); z-index:200; }
    #nameModal .box { background:#0b0b0b; padding:18px;
border-radius:10px; width:320px; color:#fff; }
    #nameModal input { width:100%; padding:8px; margin-top:8px;
border-radius:6px; border:0; }
    #nameModal button { margin-top:10px; padding:8px 10px;
border-radius:6px; border:0; cursor:pointer; }
    canvas { display:block; width:100vw; height:100vh; }
    .small { font-size:12px; color:#bfbfbf; }
    #audioStart { position:absolute; left:12px; bottom:12px;
z-index:90; padding:8px 10px; border-radius:8px; border:0;
background:#2b2b2b; color:#fff; cursor:pointer }
  </style>
</head>
<body>
  <div id="ui">
    <h1>Falcon — Top-View Landing (Final)</h1>
    <div id="controls">Controls: Arrow/WASD = steer/thrust · Mouse
wheel = thrust · Left-click hold = left · Right-click hold = right ·
Gamepad supported (DS4→XInput).</div>
    <div id="hud">VY: 0.00 | VX: 0.00 | DIST: 0.00m</div>
    <div id="score">Landing Rating: —</div>
    <div id="loading">Model: <strong>Falcon_ultra.glb</strong> —
waiting...</div>
    <label class="small">Quality (performance)</label>
    <input id="quality" type="range" min="0" max="3" value="2" />
    <div style="display:flex; gap:8px; margin-top:8px;">
      <button id="resetBtn">Reset (R)</button>
      <button id="centerBtn">Center</button>
    </div>
    <div class="small" style="margin-top:8px">Tip: If PS4 controller
doesn't map properly, enable DS4Windows XInput mode or try pressing a
gamepad button to register it.</div>
  </div>

  <div id="leaderboard">
    <h3>Top 3 Landings</h3>
    <ol id="lbList"></ol>
    <div class="small" style="margin-top:8px">Only top 3 are kept
(others discarded).</div>
  </div>

  <!-- Name prompt modal -->
  <div id="nameModal">
    <div class="box">
      <h2 style="margin:0">Enter your name</h2>
      <div class="small" style="margin-top:6px">Or press "Play as Guest"</div>
      <input id="playerNameInput" placeholder="Your name (max 16
chars)" maxlength="16" />
      <div style="display:flex; gap:8px; margin-top:8px;">
        <button id="btnPlay">Start</button>
        <button id="btnGuest">Play as Guest</button>
      </div>
    </div>
  </div>

  <canvas id="threeCanvas"></canvas>
  <button id="audioStart">Enable Sound</button>

  <!-- Three.js + GLTFLoader -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/loaders/GLTFLoader.js"></script>

  <script>
  // ---------- CONFIG ----------
  const MODEL_FILENAME = 'Falcon_ultra.glb'; // place this file next to the HTML
  const AUDIO_LANDING_FILE = 'landing_thrust.wav';
  const AUDIO_POWERDOWN_FILE = 'powerdown.wav';

  // ---------- Audio context and buffers ----------
  let audioCtx = null;
  let thrustBuffer = null;
  let powerdownBuffer = null;
  let thrustSource = null;
  let thrustGain = null;

  async function ensureAudioInit(){
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    // load buffers
    try {
      thrustBuffer = await loadSound(AUDIO_LANDING_FILE);
      powerdownBuffer = await loadSound(AUDIO_POWERDOWN_FILE);
    } catch(e){ console.warn('Audio load problem', e); }
  }

  async function loadSound(url){
    const resp = await fetch(url);
    const ab = await resp.arrayBuffer();
    return await audioCtx.decodeAudioData(ab);
  }

  function startThrustLoop(volume=0.6){
    if (!audioCtx || !thrustBuffer) return;
    if (thrustSource) return; // already playing
    thrustSource = audioCtx.createBufferSource();
    thrustSource.buffer = thrustBuffer;
    thrustSource.loop = true;
    thrustGain = audioCtx.createGain();
    thrustGain.gain.value = volume;
    thrustSource.connect(thrustGain).connect(audioCtx.destination);
    thrustSource.start(0);
  }

  function setThrustVolume(v){ if (thrustGain) thrustGain.gain.value = v; }

  function stopThrustSmooth(){
    if (!thrustSource) return;
    try {
      const g = thrustGain.gain;
      g.cancelScheduledValues(audioCtx.currentTime);
      g.linearRampToValueAtTime(0, audioCtx.currentTime + 0.6);
      setTimeout(()=>{ try{ thrustSource.stop(); }catch(e){}
thrustSource = null; thrustGain = null; }, 650);
    } catch(e){ thrustSource.stop(); thrustSource = null; thrustGain = null; }
  }

  function playPowerdownOnce(){
    if (!audioCtx || !powerdownBuffer) return;
    const s = audioCtx.createBufferSource();
    s.buffer = powerdownBuffer;
    const g = audioCtx.createGain(); g.gain.value = 0.9;
    s.connect(g).connect(audioCtx.destination);
    s.start(0);
  }

  // user gesture button
  const audioStart = document.getElementById('audioStart');
  audioStart.addEventListener('click', async ()=>{
    try{
      await ensureAudioInit();
      await audioCtx.resume();
      audioStart.style.display = 'none';
    }catch(e){ console.warn('audio failed', e); }
  });

  // ---------- Basic THREE setup ----------
  const canvas = document.getElementById('threeCanvas');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true,
powerPreference: 'high-performance' });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.25));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.outputEncoding = THREE.sRGBEncoding;
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x050609);

  let aspect = window.innerWidth / window.innerHeight;
  const VIEW_SIZE = 150;
  const camera = new THREE.OrthographicCamera(-VIEW_SIZE*aspect/2,
VIEW_SIZE*aspect/2, VIEW_SIZE/2, -VIEW_SIZE/2, -1000, 1000);
  camera.position.set(0, 220, 12);
  camera.up.set(0,0,-1);
  camera.lookAt(0,0,0);

  const dir = new THREE.DirectionalLight(0xffffff, 1.15);
  dir.position.set(80, 160, 60);
  dir.castShadow = true;
  dir.shadow.mapSize.width = 1024; dir.shadow.mapSize.height = 1024;
  scene.add(dir);
  const hemi = new THREE.HemisphereLight(0xbfe6ff, 0x202020, 0.35);
  scene.add(hemi);

  const ground = new THREE.Mesh(new THREE.PlaneGeometry(1200,1200),
new THREE.MeshStandardMaterial({color:0x060708, roughness:0.95}));
  ground.rotation.x = -Math.PI/2; ground.receiveShadow = true;
scene.add(ground);

  // landing pad
  const padGroup = new THREE.Group();
  const PAD_R = 28;
  const padBase = new THREE.Mesh(new THREE.CylinderGeometry(PAD_R,
PAD_R, 2.5, 64), new THREE.MeshStandardMaterial({color:0x111827,
metalness:0.12, roughness:0.6}));
  padBase.position.y = 1.25; padGroup.add(padBase);
  const ring = new THREE.Mesh(new THREE.TorusGeometry(PAD_R-2, 1.1,
16, 160), new THREE.MeshStandardMaterial({ color:0x0a8cff,
emissive:0x072f47, emissiveIntensity:0.25 }));
  ring.rotation.x = Math.PI/2; ring.position.y = 2.8; padGroup.add(ring);
  const xMat = new THREE.MeshStandardMaterial({ color:0xffe0d6,
metalness:0.02, roughness:0.8 });
  const barGeom = new THREE.BoxGeometry(3.0, 1.4, PAD_R*1.38);
  const x1 = new THREE.Mesh(barGeom, xMat); x1.rotation.y = Math.PI/4;
x1.position.y = 3.0; padGroup.add(x1);
  const x2 = new THREE.Mesh(barGeom, xMat); x2.rotation.y =
-Math.PI/4; x2.position.y = 3.0; padGroup.add(x2);
  padGroup.position.set(0,0,0); scene.add(padGroup);

  // booster placeholder
  const booster = new THREE.Group(); booster.position.set(0,75,0);
scene.add(booster);

  // particles
  let particleSystem = null;
  function makeParticles(count=900) {
    if (particleSystem) { booster.remove(particleSystem);
particleSystem.geometry.dispose(); particleSystem.material.dispose();
particleSystem = null; }
    const pos = new Float32Array(count*3);
    const col = new Float32Array(count*3);
    for (let i=0;i<count;i++){
      pos[i*3+0] = (Math.random()-0.5)*1.0;
      pos[i*3+1] = -Math.random()*6 -1;
      pos[i*3+2] = (Math.random()-0.5)*1.0;
      col[i*3+0] = 1; col[i*3+1] = 0.6 + Math.random()*0.35; col[i*3+2] = 0;
    }
    const geom = new THREE.BufferGeometry();
    geom.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    geom.setAttribute('color', new THREE.BufferAttribute(col, 3));
    const mat = new THREE.PointsMaterial({ size: 0.9,
vertexColors:true, transparent:true, opacity:0.95, depthWrite:false,
blending:THREE.AdditiveBlending });
    particleSystem = new THREE.Points(geom, mat);
    particleSystem.visible = false;
    booster.add(particleSystem);
  }
  makeParticles(900);

  // HUD refs
  const hud = document.getElementById('hud');
  const scoreEl = document.getElementById('score');
  const loadingEl = document.getElementById('loading');
  const lbList = document.getElementById('lbList');

  // load GLB
  const loader = new THREE.GLTFLoader();
  loader.load(MODEL_FILENAME, gltf => {
    const model = gltf.scene;
    model.traverse(m => {
      if (m.isMesh) {
        m.castShadow = true; m.receiveShadow = true;
        if (m.material && m.material.map && m.material.map.image &&
m.material.map.image.width > 2048) {
          m.material.map.anisotropy = 2;
          m.material.map.minFilter = THREE.LinearMipMapLinearFilter;
        }
      }
    });

    const bbox = new THREE.Box3().setFromObject(model);
    const size = new THREE.Vector3(); bbox.getSize(size);
    const footprint = Math.max(size.x, size.z);
    const target = PAD_R * 0.9;
    const scale = target / (footprint || 1.0);
    model.scale.setScalar(scale);
    model.rotation.x = Math.PI;
    const modelHeight = size.y*scale;
    model.position.set(0, -modelHeight/2 + 30, 0);

    booster.clear(); booster.add(model);

    const glow = new THREE.PointLight(0xffb468, 0.8, 60, 2);
glow.position.set(0, -22, 0); booster.add(glow);

    loadingEl.textContent = 'Model loaded — ready';
  }, xhr => {
    if (xhr && xhr.loaded && xhr.total) loadingEl.textContent =
`Loading model: ${Math.round(xhr.loaded/xhr.total*100)}%`;
  }, err => { console.error(err); loadingEl.textContent = 'Failed to
load model — ensure Falcon_ultra.glb is next to the HTML'; });

  // leaderboard
  function loadLeaderboard(){ try{ return
JSON.parse(localStorage.getItem('falconTop3')) || []; } catch(e){
return []; } }
  function saveLeaderboard(list){ localStorage.setItem('falconTop3',
JSON.stringify(list.slice(0,3))); }
  function updateLeaderboardUI(){ const list = loadLeaderboard();
lbList.innerHTML = ''; for (const entry of list){ const li =
document.createElement('li'); li.textContent = `${entry.name}:
${entry.score.toFixed(1)}%`; lbList.appendChild(li); } }
  updateLeaderboardUI();

  // name modal logic
  const nameModal = document.getElementById('nameModal');
  const playerInput = document.getElementById('playerNameInput');
  let playerName = 'Guest';
  document.getElementById('btnPlay').addEventListener('click', ()=>{
const v = playerInput.value.trim(); playerName = v.length ?
v.slice(0,16) : 'Guest'; nameModal.style.display = 'none'; });
  document.getElementById('btnGuest').addEventListener('click', ()=>{
playerName = 'Guest'; nameModal.style.display = 'none'; });

  // inputs
  let keyLeft=false, keyRight=false, keyUp=false, keyDown=false; let
leftMouse=false, rightMouse=false; window.addEventListener('keydown',
e=>{ if (e.key === 'ArrowLeft' || e.key === 'a') keyLeft = true; if
(e.key === 'ArrowRight' || e.key === 'd') keyRight = true; if (e.key
=== 'ArrowUp' || e.key === 'w') keyUp = true; if (e.key ===
'ArrowDown' || e.key === 's') keyDown = true; if (e.key === 'r' ||
e.key === 'R') doReset(); }); window.addEventListener('keyup', e=>{ if
(e.key === 'ArrowLeft' || e.key === 'a') keyLeft = false; if (e.key
=== 'ArrowRight' || e.key === 'd') keyRight = false; if (e.key ===
'ArrowUp' || e.key === 'w') keyUp = false; if (e.key === 'ArrowDown'
|| e.key === 's') keyDown = false; });
  document.addEventListener('mousedown', e=>{ if (e.button === 0)
leftMouse = true; if (e.button === 2) rightMouse = true; });
document.addEventListener('mouseup', e=>{ if (e.button === 0)
leftMouse = false; if (e.button === 2) rightMouse = false; });
document.addEventListener('contextmenu', e=>e.preventDefault());
document.addEventListener('wheel', e=>{ if (e.deltaY < 0)
booster.userData.thrust = Math.min(1.0, (booster.userData.thrust||0) +
0.36); else booster.userData.thrust = Math.max(0,
(booster.userData.thrust||0) - 0.12); });

  // gamepad
  let gamepadIndex = null; window.addEventListener('gamepadconnected',
e=>{ gamepadIndex = e.gamepad.index; console.log('GP connected',
e.gamepad.id); }); window.addEventListener('gamepaddisconnected', e=>{
gamepadIndex = null; console.log('GP disconnected'); });
  function readGamepad(){ if (gamepadIndex === null) return { x:0,
y:0, thrust:0 }; const gp = navigator.getGamepads()[gamepadIndex]; if
(!gp) return { x:0, y:0, thrust:0 }; let ax = gp.axes[0] || 0; let ay
= gp.axes[1] || 0; let thrust = 0; if (gp.buttons[7]) thrust =
gp.buttons[7].value; else if (gp.buttons[0] && gp.buttons[0].pressed)
thrust = 0.8; if (Math.abs(ax) < 0.02 && gp.axes.length > 2) ax =
gp.axes[2] || ax; return { x: ax, y: ay, thrust }; }

  // scoring
  function computeScore(dist, vVert, vHor){ const maxDist = PAD_R;
const dScore = clamp(1 - (dist / maxDist), 0, 1); const vV = clamp(1 -
(Math.abs(vVert) / 5.0), 0, 1); const vH = clamp(1 - (Math.abs(vHor) /
5.0), 0, 1); const total = (0.5 * dScore) + (0.35 * vV) + (0.15 * vH);
return clamp(total * 100, 0, 100); } function clamp(v,a,b){ return
Math.max(a, Math.min(b, v)); }

  // reset/center
  function doReset(){ state.pos.set(0,75,0); state.vx = 0; state.vy =
-0.12; state.vz = 0; booster.position.copy(state.pos); state.landed =
false; booster.userData.thrust = 0; scoreEl.textContent = 'Landing
Rating: —'; }
  document.getElementById('resetBtn').addEventListener('click',
doReset); document.getElementById('centerBtn').addEventListener('click',
()=>{ camera.position.set(0,220,12); camera.lookAt(0,0,0); });

  // quality slider
  const qualityInput = document.getElementById('quality');
qualityInput.addEventListener('input', ()=>{ const q =
parseInt(qualityInput.value); if (particleSystem &&
particleSystem.material) particleSystem.material.size = q >= 2 ? 0.9 :
0.55; if (q <= 1) renderer.setPixelRatio(Math.min(1.0,
window.devicePixelRatio || 1)); else
renderer.setPixelRatio(Math.min(1.25, window.devicePixelRatio ||
1.25)); });

  // audio helpers
  let landingPlayed = false; function playLandingSequence(){ if
(!landingPlayed){ landingPlayed = true; try{ startThrustLoop(0.8);
}catch(e){} setTimeout(()=>{ try{ stopThrustSmooth();
playPowerdownOnce(); }catch(e){} }, 850); } }

  // main loop
  let last = performance.now(); function animate(now){
requestAnimationFrame(animate); const dt = Math.min(0.05, (now -
last)/1000); last = now;
    if (booster.children.length > 0 && !state.landed){ const gp =
readGamepad(); let lateral = 0; if (keyLeft) lateral -= 1; if
(keyRight) lateral += 1; if (leftMouse) lateral -= 1; if (rightMouse)
lateral += 1; lateral += gp.x || 0; if (keyUp) booster.userData.thrust
= clamp((booster.userData.thrust||0) + 0.68 * dt * 4, 0, 1); if
(keyDown) booster.userData.thrust = clamp((booster.userData.thrust||0)
- 0.4 * dt * 4, 0, 1); booster.userData.thrust =
clamp(booster.userData.thrust + (gp.thrust || 0) * 0.32 * dt * 10, 0,
1);
      const thrustPower = 12.0 * (0.4 + booster.userData.thrust * 1.5);
      state.vy += ((thrustPower/60) - (9.8*0.06)) * dt * 60;
      state.vx += lateral * 0.15 * dt * 60;
      state.vx *= (1 - 0.04 * dt * 60);
      state.vy *= (1 - 0.003 * dt * 60);
      state.pos.x += state.vx * dt * 60; state.pos.y += state.vy * dt
* 60; booster.position.copy(state.pos);
      if (particleSystem){ particleSystem.visible =
(booster.userData.thrust > 0.05); if (particleSystem.visible){ const
positions = particleSystem.geometry.attributes.position.array; for
(let i=0;i<positions.length/3;i++){ positions[i*3+0] +=
(Math.random()-0.5) * 0.02; positions[i*3+1] += -0.06 -
Math.random()*0.12; positions[i*3+2] += (Math.random()-0.5) * 0.02; if
(positions[i*3+1] < -8) positions[i*3+1] = -1 - Math.random()*3; }
particleSystem.geometry.attributes.position.needsUpdate = true; } }
      if (booster.userData.thrust > 0.05){ // start thrust audio if available
        (async ()=>{ try{ await ensureAudioInit(); startThrustLoop(0.6
+ booster.userData.thrust*0.6); setThrustVolume(0.5 +
booster.userData.thrust*0.8); }catch(e){} })();
      } else { stopThrustSmooth(); }
      if (state.pos.y <= 6.0){ const dx = state.pos.x -
padGroup.position.x; const dz = state.pos.z - padGroup.position.z;
const dist = Math.hypot(dx, dz); const vVert = state.vy; const vHor =
Math.hypot(state.vx, state.vz || 0); const score = computeScore(dist,
vVert, vHor); playLandingSequence(); let list = loadLeaderboard();
const lowest = list.length < 3 ? -1 : list[list.length-1].score; if
(list.length < 3 || score > lowest){ list.push({ name: playerName ||
'Guest', score: score }); list.sort((a,b) => b.score - a.score); list
= list.slice(0,3); saveLeaderboard(list); updateLeaderboardUI(); }
        scoreEl.textContent = `Landing Rating: ${score.toFixed(1)}%
(dist:${dist.toFixed(2)}m | vY:${vVert.toFixed(2)} |
vH:${vHor.toFixed(2)})`;
        state.landed = true; if (score < 40){ const flash = new
THREE.Mesh(new THREE.PlaneGeometry(60,60), new
THREE.MeshBasicMaterial({ color: 0xff4400, transparent:true,
opacity:0.85 })); flash.rotation.x = -Math.PI/2; flash.position.y = 3;
scene.add(flash); setTimeout(()=>scene.remove(flash), 700); }
        setTimeout(()=>{ doReset(); landingPlayed = false; }, 2000);
      }
    }
    const distNow = Math.hypot(state.pos.x - padGroup.position.x,
state.pos.z - padGroup.position.z);
document.getElementById('hud').textContent =
`VY:${state.vy.toFixed(2).padStart(6)} |
VX:${state.vx.toFixed(2).padStart(6)} | DIST:${distNow.toFixed(2)}m`;
    renderer.render(scene, camera);
  }
  requestAnimationFrame(animate);

  // init
  function updateLeaderboardUI(){ const list = loadLeaderboard();
lbList.innerHTML = ''; for (const entry of list){ const li =
document.createElement('li'); li.textContent = `${entry.name}:
${entry.score.toFixed(1)}%`; lbList.appendChild(li); } }
  updateLeaderboardUI(); doReset();

  window.addEventListener('resize', ()=>{
renderer.setSize(window.innerWidth, window.innerHeight); aspect =
window.innerWidth / window.innerHeight; camera.left = -VIEW_SIZE *
aspect / 2; camera.right = VIEW_SIZE * aspect / 2;
camera.updateProjectionMatrix(); });

  // ensure audio can be primed by a user gesture
  document.addEventListener('pointerdown', ()=>{ if (!audioCtx)
ensureAudioInit().then(()=>{ try{ if (thrustBuffer) { /* prime */ }
}catch(e){} }); }, { once:true });
  </script>
</body>
</html>
